<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Qian's Blog - RISC-V</title><link href="https://qian-gu.github.io/" rel="alternate"></link><link href="https://qian-gu.github.io/feeds/risc-v.atom.xml" rel="self"></link><id>https://qian-gu.github.io/</id><updated>2024-04-13T14:26:00+08:00</updated><subtitle>Read &gt;&gt; Think &gt;&gt; Write</subtitle><entry><title>RISC-V Book 阅读笔记</title><link href="https://qian-gu.github.io/posts/risc-v/riscv-book-note.html" rel="alternate"></link><published>2024-04-13T14:26:00+08:00</published><updated>2024-04-13T14:26:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2024-04-13:/posts/risc-v/riscv-book-note.html</id><summary type="html">&lt;p&gt;The RISC-V Reader: An Open Architecture Atlas 读书笔记&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#risc-v"&gt;为什么要有 RISC-V？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#isa"&gt;ISA 设计导论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32irisc-v"&gt;RV32I：RISC-V 基础整数指令集&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#rv32i"&gt;RV32I 指令格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_1"&gt;RV32I 寄存器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_2"&gt;RV32I 整数计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_3"&gt;RV32I 取数和存数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_4"&gt;RV32I 条件分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_5"&gt;RV32I 无条件跳转&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_6"&gt;其他 RV32I 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#risc-v_1"&gt;RISC-V 汇编语言&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;函数调用过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32m"&gt;RV32M：乘法和除法指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_5"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32f-rv32d"&gt;RV32F 和 RV32D：单精度和双精度浮点数&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_6"&gt;浮点寄存器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;浮点取数、存数和算术运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32a"&gt;RV32A：原子指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_9"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32c"&gt;RV32C：压缩指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_10"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32v"&gt;RV32V：向量&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_11"&gt;向量计算指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_12"&gt;向量寄存器和动态类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_13"&gt;向量取数和存数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_14"&gt;向量操作的并行度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_15"&gt;向量操作的条件执行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_16"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv6464"&gt;RV64：64 位地址指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_17"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv3264"&gt;RV32/64 特权架构&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_18"&gt;机器模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_19"&gt;机器模式的异常处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_20"&gt;嵌入式系统中的用户模式和进程隔离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_21"&gt;现代操作系统的监管模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_22"&gt;页式虚拟内存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_23"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="risc-v"&gt;为什么要有 RISC-V？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;大道至简。&lt;/p&gt;
&lt;p&gt;—— 列奥纳多 · 达 · 芬奇（Leonardo da Vinci）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;年轻、开放、模块化。&lt;/p&gt;
&lt;h3 id="isa"&gt;ISA 设计导论&lt;/h3&gt;
&lt;p&gt;计算机架构师在设计 ISA 时需要遵守的基本原则和做出权衡，评价一个 ISA 的 7 个指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成本&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;ISA 越简单，area 越小，成本越低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;简洁&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;简洁不光可以节省制造成本，还能节省设计和验证时间，降低文档开销，使得用户更加容易了解和使用。高端 implement 可以通过组合简单指令来提升性能，但是如果直接在 ISA 中添加更大、更复杂的指令会给低端 implement 带来负担。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;完成相同的任务，RISC 比 CISC 需要的指令更多，但是 RISC 因为其 ISA 的简洁性，可以通过更高的时钟频率和更小的 CPI 来弥补。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;架构和实现分离&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;延迟分支槽：MIPS-32 ISA 在 architecture 层面解决某一时期某个 implement 的问题，导致其他和后续的 implement 为了保持向后兼容不得不做一些无用的工作。&lt;/p&gt;
&lt;p&gt;架构师除了不应该加入那些仅有助于一个 implement 的功能，也不应该加入阻碍某些实现的功能。比如 ARM-32 提供的 load multiple 指令，这个指令可以提升单发射 pipeline 的性能，但是会对多发射 pipeline 带来负面影响。因为简单的多发射实现无法支持 load multiple 指令和其他指令的并行调度，所以要么实现更复杂的多发射机制，要么降低这种情况下的指令吞吐。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提升空间&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;随着摩尔定律的终结，大幅提高性价比的唯一途径是 DSA（为特定领域添加自定义指令，如 DL、AR 等），所以 ISA 必须预留操作码空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码大小&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;让代码变短是 ISA 架构师的目标，因为可以降低所需存储器的面积（嵌入式的一项巨大成本），降低 I$ 的 miss ratio，从而降低功耗（访问片外 DRAM 代价远高于片上 SRAM）并提升性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;易于编程 / 编译 / 链接&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;GPR 数量越多，编译器和汇编程序员的工作越轻松。ARM-32 有 16 个寄存器，X86-32 只有 8 个，现代 ISA 都有相对较多的 32 个。&lt;/p&gt;
&lt;p&gt;位置无关代码（Position Independent Code, PIC）有助于支持动态链接，因为共享库的代码可以放在不同地址。PC 相对分支和数据寻址是 PIC 的福音，RISC-V 支持 PC 相对寻址，但是 x86-32 和 MIPS-32 不支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;ISA 就好比俄罗斯方块中的方块形状集合，集合要设计的够用且不冗余。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="_1"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用形式逻辑方法容易看出，存在某种抽象的 [ 指令集 ]，足以控制和执行任意操作序列 …… 现在看来，选择一款 [ 指令集 ] 的真正决定性因素更多是实用性：[ 指令集 ] 所需装置的简洁性，应用于实际重要问题的清晰度，以及处理这些问题的速度。
——[Burks et al. 1946]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RISC-V 是一款最新的、清晰的、简约的、开放的 ISA，它以过去 ISA 所犯错误为鉴。RISC-V 架构师的目标是让它能用于从最小到最快的所有计算设备。遵循冯 · 诺依曼在 1940 年代的建议，RISC-V 强调简洁性以保持低成本，同时拥有大量寄存器和直观的指令执行速度，从而帮助编译器和汇编语言程序员将实际的重要问题转换为适当的高效代码。&lt;/p&gt;
&lt;h2 id="rv32irisc-v"&gt;RV32I：RISC-V 基础整数指令集&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;…… 提升计算性能并让用户切实享受到性能提升的唯一方法是同时设计编译器和计算机。这样软件用不到的特性将不会在硬件上实现 ……&lt;/p&gt;
&lt;p&gt;—— 法兰 · 艾伦（Frances Elizabeth “Fran” Allen），1981&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="rv32i"&gt;RV32I 指令格式&lt;/h3&gt;
&lt;p&gt;简洁的指令格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁：四种基础格式 R(egister) + I(mmediate) + S(tore) + U(pper) + 两种扩展格式 B(ranch) + J(ump)&lt;/li&gt;
&lt;li&gt;性能：支持 3 个操作数&lt;/li&gt;
&lt;li&gt;性能：rs1，rs2，rd 位置固定，在 dec 前访问 GPR&lt;/li&gt;
&lt;li&gt;性能：imm 的符号位永远在 inst[31]，符号位扩展可在 dec 前进行&lt;/li&gt;
&lt;li&gt;易于编程：全 0 和全 1 为非法指令&lt;/li&gt;
&lt;li&gt;成本：精心挑选 op_code，使得 datapath 相同的指令共享 op_code，从而简化控制逻辑&lt;/li&gt;
&lt;li&gt;提升空间：RV32I 占用 32bit 指令编码空间不到 1/8，预留指令编码空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_1"&gt;RV32I 寄存器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;易于编程：RISC-V = 32 个 GPR + 1 PC；ARM-32 = 16 个 GPR（包含 PC）&lt;/li&gt;
&lt;li&gt;简洁：实现相同功能，设置 x0 为常 0 可以简化操作，额外设置 PC 可以简化分支预测复杂度，且少占用一个 GPR&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_2"&gt;RV32I 整数计算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：imm 总是符号位扩展，所以无需 imm 版本的 sub 指令&lt;/li&gt;
&lt;li&gt;简洁：虽然 branch 支持 2 个 GPR 之间的所有运算关系，还是提供 slt 方便处理更复杂的条件表达式&lt;/li&gt;
&lt;li&gt;易于编程：lui 搭配后续一条指令，可以构造出 32bit 的 imm；auipc 搭配 jal/jalr 可以实现相对于 PC 的任意偏移跳转和数据访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_3"&gt;RV32I 取数和存数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RV32I 只支持一种标准寻址模式： &lt;strong&gt;偏移寻址&lt;/strong&gt; ，即跳转地址 = 寄存器 + imm[11:0]&lt;/li&gt;
&lt;li&gt;简洁：没有栈指令，ABI 中指定 x2 为 sp 就能使得标准寻址模式具有 push/pop 的优点，无需增加 ISA 复杂度&lt;/li&gt;
&lt;li&gt;易于编程：ARM-32 和 MIPS-32 要求数据按其长度对齐，RISC-V 无此要求&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;因为一条 32bit 指令无法容纳 32bit 地址，所以 linker 通常要把每个符号调整成 2 条 RV32I 指令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于数据地址，需要调整为 lui 和 addi&lt;/li&gt;
&lt;li&gt;对于代码地址，需要调整为 auipc 和 jalr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多时候跳转距离没那么大，此时并不需要两条，linker 会多趟扫描代码，尽可能优化成一条 jal 指令（包含 imm[19:0]，可以寻址前后 1MB），这个过程叫做 linker relaxation。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="rv32i_4"&gt;RV32I 条件分支&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RISC-V 没有 MIPS-32 的延迟分支，也没有 ARM-32 和 x86-32 的条件码&lt;/li&gt;
&lt;li&gt;简洁：auipc 的 imm 为 0 就可以得到当前 PC，x86-32 需要先调用函数把 PC push，然后读出 PC，最后再 pop&lt;/li&gt;
&lt;li&gt;简洁：大部分程序都忽略整数的算术溢出，所以 RISC-V 让软件检测溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_5"&gt;RV32I 无条件跳转&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RV32I 不支持复杂的过程调用指令，如 x86-32 的 enter/leave，Tensilica 的 register windows&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition info"&gt;
&lt;p class="admonition-title"&gt;Info&lt;/p&gt;
&lt;p&gt;register windows：通过远多于 32 个 GPR 来加速函数调用。在函数调用时，为其分配新的一组 32 个寄存器（也称为窗口），为了支持传参，两个函数的窗口会重叠，即有些寄存器同时属于两个相邻的窗口。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="rv32i_6"&gt;其他 RV32I 指令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RISC-V 通过 memory-map IO 来访问设备，没有 x86-32 的专用 I/O 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;那些遗忘过去的人注定要重蹈覆辙。&lt;/p&gt;
&lt;p&gt;—— 乔治 · 桑塔亚那（George Santayana），1905&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;得益于起步时间比过去的 ISA 晚 20∼30 年，RISC-V 架构师可以实践 Santayana 的建议，借鉴包括 RISC-I 在内不同 ISA 的设计，取其精华，去其糟粕。此外，RISC-V 国际基金会将以可选扩展的方式缓慢地演进指令集，以规避给过去的成功 ISA 造成麻烦的野蛮生长现象。&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;p&gt;图 2.7 按照 7 个评价指标汇总了 ARM-32、MIPS-32、x86-32 和 RV32I 的对比&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="risc-v_1"&gt;RISC-V 汇编语言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给看似困难的问题找到简单的解法往往令人满足，而最好的解法通常是简单的。&lt;/p&gt;
&lt;p&gt;—— 伊凡 · 苏泽兰（Ivan Sutherland）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_3"&gt;函数调用过程&lt;/h3&gt;
&lt;p&gt;通常分为 6 个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;caller 将参数放到 callee 可访问的位置&lt;/li&gt;
&lt;li&gt;调换到 callee 的入口（使用 jal）&lt;/li&gt;
&lt;li&gt;获取函数所需的局部存储资源，按需保存 GPR&lt;/li&gt;
&lt;li&gt;执行函数功能&lt;/li&gt;
&lt;li&gt;将返回值放到 caller 可访问的位置，恢复 GPR，释放局部存储资源&lt;/li&gt;
&lt;li&gt;将控制权返回给 caller（使用 ret）&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;保存寄存器由 callee 负责维护，重新解释上述过程如下：&lt;/p&gt;
&lt;p&gt;在 caller 中执行 call 指令跳转进入 callee 后，callee 首先做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分配 stack frame，为保存现场准备资源&lt;/li&gt;
&lt;li&gt;将 callee 需要维护的保存寄存器存储到 stack 中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当 callee 完成功能后，执行 ret 指令前做两件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 stack 向保存寄存器恢复现场&lt;/li&gt;
&lt;li&gt;恢复保存寄存器 &lt;code&gt;sp&lt;/code&gt; == 释放 stack frame（局部资源）&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;为了提升性能，应尽量把变量放在 GPR 中而不是内存中，同时要避免因为保存和恢复 GPR 而频繁访问内存。RISC-V 有足够的寄存器兼顾两者：既能把操作数放在 GPR，又能减少保存和恢复它们的次数。关键在于，一些寄存器不保证其值在函数调用前后保持一致，称为临时寄存器；另一些能保证，称为保存寄存器。不再调用其他函数的函数称为叶子函数。当一个叶子函数只有少量参数和局部变量时，可将其分配到寄存器，无需分配到内存。大部分函数调用均如此，此时程序无需将寄存器保存到内存。&lt;/p&gt;
&lt;p&gt;典型例子 main 函数调用 prinf：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# 编译，将 c 代码转化为 asm 代码，结果如图 3.6&lt;/span&gt;
gcc&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;hello.s&lt;span class="w"&gt; &lt;/span&gt;-S&lt;span class="w"&gt; &lt;/span&gt;hello.c
&lt;span class="c1"&gt;# 编译，将 asm 代码转化为 .o 文件，.o 文件无法直接查看，需要先 dump，结果如图 3.7&lt;/span&gt;
&lt;span class="c1"&gt;# 其中一些指令的地址字段是 0，需要 linker 填充&lt;/span&gt;
gcc&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;hello.o&lt;span class="w"&gt; &lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;hello.s
objdump&lt;span class="w"&gt; &lt;/span&gt;-D&lt;span class="w"&gt; &lt;/span&gt;hello.o&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;hello.o.dump
&lt;span class="c1"&gt;# 链接，将 .o 文件转化为 elf 文件，elf 文件无法直接查看，需要先 dump，结果如图 3.8&lt;/span&gt;
&lt;span class="c1"&gt;# 地址字段已替换&lt;/span&gt;
gcc&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;hello&lt;span class="w"&gt; &lt;/span&gt;hello.c
objdump&lt;span class="w"&gt; &lt;/span&gt;-D&lt;span class="w"&gt; &lt;/span&gt;hello&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;hello.dump
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_4"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;保持简洁，直接。&lt;/p&gt;
&lt;p&gt;—— 凯利 · 约翰逊（Kelly Johnson），提出 “KISS 原则 ” 的航空工程师，1960&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;汇编器向简洁的 RISC-V ISA 增加了 60 条伪指令，在不增加硬件开销的同时令 RISC-V 代码更易于读写。RISC-V 提供一系列简单有效的机制，可降低成本、提高性能、易于编程。&lt;/p&gt;
&lt;h2 id="rv32m"&gt;RV32M：乘法和除法指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;若无必要，勿增实体。&lt;/p&gt;
&lt;p&gt;—— 奥卡姆的威廉（William of Occam），约 1320&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在几乎任何处理器上，执行速度：移位 &amp;gt; 乘法 &amp;gt;&amp;gt; 除法。&lt;/li&gt;
&lt;li&gt;除以常数，可以转化成乘以一个近似的倒数，再校正积的高位部分&lt;/li&gt;
&lt;li&gt;ARM-32 在 2005 之后才添加了除法指令；MISP-32 使用特殊的寄存器作为乘除法的 rd，所以需要额外的传送指令，会降低性能，增加体系结构的状态，降低切换任务的速度&lt;/li&gt;
&lt;li&gt;mulh 和 mulhu 可以检查乘法溢出&lt;/li&gt;
&lt;li&gt;除数为 0 不会产生 trap，所以可以只在需要时通过 beqz 检查除数是否为 0&lt;/li&gt;
&lt;li&gt;mulhsu 对 multi-word singed 乘法很有用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_5"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;最便宜、最快且最可靠的组件是那些不存在的组件。&lt;/p&gt;
&lt;p&gt;—— 切斯特 · 戈登 · 贝尔（C. Gordon Bell），著名小型计算机架构师&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="rv32f-rv32d"&gt;RV32F 和 RV32D：单精度和双精度浮点数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;达成完美之时并非无所可增，而是无所可减。&lt;/p&gt;
&lt;p&gt;—— 安托万 · 德 · 圣埃克絮佩里（Antoine de Saint-Exupéry），《人的大地》，1939&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_6"&gt;浮点寄存器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能：4 种指令格式中 rs 和 rd 只有 5bit 刚好表达 32 个 x 寄存器，为了保持指令格式不变，为浮点另外设置一组（32 个）f 寄存器&lt;/li&gt;
&lt;li&gt;如果只支持 RV32F 则 FLEN=32，如果支持 RV32D 则 FLEN=64&lt;/li&gt;
&lt;li&gt;fcsr 用于存放 round mode 和精确异常 flag&lt;/li&gt;
&lt;li&gt;ARM-32 和 MIPS-32 有 32 个 float 寄存器，但是只有 16 个 double 寄存器（把两个 float 拼接成一个 double 使用）&lt;/li&gt;
&lt;li&gt;x86-32 浮点运算早期使用 stack 而不是寄存器，后续版本增加了 8 个 64bit 浮点寄存器&lt;/li&gt;
&lt;li&gt;ARM-32 和 x86-32 不支持 x 和 f 寄存器之间直接传送数据的指令，要实现该功能，必须先写内存，再读内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_7"&gt;浮点取数、存数和算术运算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能：许多浮点运算（矩阵乘法）在乘法后立即执行一次加法 / 减法，所以 RISC-V 提供了 fmadd、fmsub、fnmadd、fnmsub 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_8"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;少即是多。&lt;/p&gt;
&lt;p&gt;—— 罗伯特 · 勃朗宁（Robert Browning），1855。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="rv32a"&gt;RV32A：原子指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一切事物都应该尽量简单，但不能过分简单。&lt;/p&gt;
&lt;p&gt;—— 阿尔伯特 · 爱因斯坦（Albert Einstein），1933&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RV32A 用于同步的原子操作有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子内存操作（atomic memory operation，AMO）&lt;/li&gt;
&lt;li&gt;预订取数 / 条件存数（load reserved / store conditional）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为何 RV32A 要提供两种原子操作？答案是对应两种区别很大的使用场景。&lt;/p&gt;
&lt;p&gt;场景一：编程语言开发者假定顶层的 ISA 提供原子的 compare-and-swap 操作：比较某寄存器和另一寄存器寻址的内存值，若相等，则将第 3 个寄存器的值与内存值交换。这是一种通用的同步原语，基于它可以实现其他任意 word 同步操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# 用 lr/sc 对内存 M[a0] 进行 compare-and-swap
# 期望的旧值在 a1 中；期望的新值在 a2 中
0: lr.w a3, (a0)  # 取出旧值
4: bne a3, a1, 80  # 旧值是否等于 a1？
8: sc.w a3, a2, (a0)  # 如果相等，则换入新值
c: bnez a3, 0  # 如果失败，重试
... compare-and-swap 成功后的代码 ...
...
80:  # compare-and-swap 失败
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;场景二：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# 用 AMO 实现 test-and-set 自旋锁，用于保护临界区
0: li t0, 1 # 初始化锁值
4: amoswap.w.aq t1, t0, (a0) # 尝试获取锁
8: bnez t1, 4 # 若失败则重试
... 临界区代码 ..
20: amoswap.w.rl x0, x0, (a) # 释放锁
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_9"&gt;结语&lt;/h3&gt;
&lt;p&gt;RV32A 是可选的，一个不支持它的 RISC-V 处理器会更简单。然而，正如爱因 斯坦所言，一切事物都应该尽量简单，但不能过分简单。RV32A 正是如此，许多场景 都离不开它。&lt;/p&gt;
&lt;h2 id="rv32c"&gt;RV32C：压缩指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;小即是美。&lt;/p&gt;
&lt;p&gt;—— 恩斯特 · 弗里德里希 · 舒马赫（E. F. Schumacher），1973&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;代码大小：以前的 ISA 为缩减代码大小而添加很多指令和指令格式，ARM 和 MIPS 分别对 ISA 重新设计了两遍：ARM 设计了 ARM Thumb 和 Thumb2，MIPS 则设计了 MIPS16 和 microMIPS。这些新 ISA 给处理器和编译器带来额外的设计开销，同时还增加汇编语言程序员的认知负担。&lt;/li&gt;
&lt;li&gt;简洁：RV32C 采用一种新方法：每条短指令都必须对应一条标准的 32 位 RISC-V 指 令。此外，16 位指令仅对汇编器和链接器可见，并由它们决定是否将标准指令替换为相应的短指令。编译器开发者和汇编语言程序员无需关心 RV32C 指令及其格式，他 们只需知道最终得到的程序比大部分情况下更小。&lt;/li&gt;
&lt;li&gt;成本：尽管处理器设计者不能忽略 RV32C 指令，但能通过以下技巧降低实现开销：在执 行指令前通过一个译码器将所有 16 位指令翻译成相应的 32 位指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么有些架构师会跳过 RV32C：16bit 的 RV32C 和 32bit 的 RV32I 混合在一起会恶化 decoder 的时序，而在高性能处理器中，dec 本身就是时序瓶颈，所以很难处理这种情况。典型例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;superscalar 一个 cycle 内 decode 多条指令&lt;/li&gt;
&lt;li&gt;宏融合 macrofusion：decoder 把多条指令组合成更复杂的指令来执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_10"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;我本能写出更短的信，但我没有时间。&lt;/p&gt;
&lt;p&gt;—— 布莱兹 · 帕斯卡（Blaise Pascal），1656。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RV32C 让 RISC-V 编译出当今几乎最短的代码。您几乎能将其视为硬件辅助的伪指令。但这里汇编器将其隐藏起来，汇编语言程序员和编译器开发者无需感知。&lt;/p&gt;
&lt;h2 id="rv32v"&gt;RV32V：向量&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我追求简洁，无法理解复杂的事物。&lt;/p&gt;
&lt;p&gt;—— 西摩 · 克雷（Seymour Cray）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;性能：注数据级并行，该技术用于可在大量数据上并发计算的目标应用程序。最著名的数据级并行架构是 SIMD（Single Instruction Multiple Data，单指令多数据）。&lt;/li&gt;
&lt;li&gt;架构和实现分离：将向量长度和每个时钟周期的最大操作次数与指令编码分离，是向量架构的关键。向量微架构师可灵活设计数据并行硬件单元，不会影响程序员，而程序员无需重写代码即可享受更长向量的好处。&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接：向量架构的指令数量比 SIMD 架构少得多。而且，与 SIMD 不同，向量架构的编译技术十分完善。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_11"&gt;向量计算指令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RV32IMAFD 每一条整数和浮点计算指令基本都有对应的向量版本&lt;/li&gt;
&lt;li&gt;每条向量指令根据操作数的类型，有多个版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_12"&gt;向量寄存器和动态类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;32 个名称以 v 开头的向量寄存器，但每个向量寄存器的元素数量并不固定，取决于操作的位宽和向量寄存器堆大小，后者由处理器设计者决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VLEN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;每个 VRF 的位宽，单位为 bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mvl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单条指令能正确运行的最大向量元素个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;待处理的向量元素个数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;易于编程 / 编译 / 链接：RV32V 采取将数据类型和位宽与向量寄存器关联的新方法，而不是与指令操作码关联。程序在执行向量计算指令前，先在向量寄存器中设置数据类型和位宽。使用动态寄存器类型可大幅减少向量指令数量。动态类型向量架构能降低汇编语言程序员的认知负担和编译器中代码生成器的复杂度。&lt;/li&gt;
&lt;li&gt;向量架构不如 SIMD 架构流行的一个原因是，大家担心添加很大的向量寄存器会增加中断时保存和恢复程序（上下文切换）的开销。动态寄存器类型有助于改善此情况。根据 RV32V 约定，软件在不使用向量指令时需要禁用所有向量寄存器，这意味着处理器既具备向量寄存器的性能优势，又仅在向量指令执行过程中发生中断时才引入额外的上下文切换开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_13"&gt;向量取数和存数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;易于编程 / 编译 / 链接：虽然可以设置 stride = 1 使得 stride 兼容 unistride，但是提供 unistride 指令可以缩小代码体积和指令数。（vlds/vsts 需要 2 个 rs，而 vld/vst 只需要 1 个）&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接：为了支持稀疏数组，提供 index 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_14"&gt;向量操作的并行度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能：向量元素之间独立，硬件可以并行计算，每个 cycle 计算的元素数量由 VLEN 和 EEW 决定&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接：在 SIMD 架构中，由 ISA 架构师决定每个 cycle 并行操作的最大数量和每个寄存器的元素数量，如果寄存器位宽翻倍，则指令数也翻倍，还需要同步修改编译器。RV32V 则由 implementation 决定，无需修改 ISA 和编译器，同一份 RV32V 程序，无需修改（修改代码和重新编译）就可以同时在最简单或最激进的向量处理器上运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_15"&gt;向量操作的条件执行&lt;/h3&gt;
&lt;p&gt;一些向量计算包含 if 语句。向量架构不依赖于条件分支，而是用掩码禁止部分元素的向量操作。&lt;/p&gt;
&lt;h3 id="_16"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;若代码可向量化，最好的架构就是向量架构。&lt;/p&gt;
&lt;p&gt;—— 吉姆 · 史密斯（Jim Smith）于 1994 年在国际计算机体系结构研讨会（ISCA）上的主题演讲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="rv6464"&gt;RV64：64 位地址指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机设计中只有一种错误难以恢复 —— 用于存储器寻址和存储管理的地址位 不足。&lt;/p&gt;
&lt;p&gt;—— 切斯特 · 戈登 · 贝尔，1976&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;代码大小：RV64 基本上是 RV32 的超集，唯一例外是压缩指令。&lt;/li&gt;
&lt;li&gt;与 RISC-V 不同，ARM 决定采用最大主义方法来设计 ISA。&lt;/li&gt;
&lt;li&gt;成本：程序大小的差异显著，让 RV64 要么能通过较低的指令缓存缺失率提升性能，要么在缺失率尚可接受的前提下，采用更小的指令缓存来降低成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_17"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;成为先驱的一个问题是你总会犯错误，而我永远不想成为先驱。在看到先驱所犯错误后，第二个做这件事才是最好的。&lt;/p&gt;
&lt;p&gt;—— 西摩 · 克雷（Seymour Cray），第一台超级计算机的架构师，1976 年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;64 位架构更能体现 RISC-V 设计的合理性，这对 20 年后才开始设计的我们是更容易实现的，因为我们能借鉴先驱经验，取其精华，去其糟粕。&lt;/p&gt;
&lt;h2 id="rv3264"&gt;RV32/64 特权架构&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;简洁是可靠性的前提。&lt;/p&gt;
&lt;p&gt;—— 艾兹赫尔 · 韦伯 · 戴克斯特拉（Edsger W. Dijkstra）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;高特权模式通常能访问低特权模式的所有功能，同时还具备若干低特权模式下不可用的额外功能，如中断处理和 I/O 操作。处理器通常在最低特权模式下运行，当发生中断和异常时，则将控制权转移到更高特权的模式。&lt;/p&gt;
&lt;p&gt;RV 的 3 种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;machine mode&lt;/li&gt;
&lt;li&gt;supervisor mode&lt;/li&gt;
&lt;li&gt;user mode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特权架构指令很少，但是增加了若干 csr 来实现其新增功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RV32 和 RV64 特权架构，两者的差异仅体现在整数寄存器的位宽。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_18"&gt;机器模式&lt;/h3&gt;
&lt;p&gt;机器模式最重要的特性是拦截和处理异常 exception（不寻常的 runtime event）。RISC-V 将 exception 分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步异常 synchronous exception：指令执行的结果，比如访问非法地址，指令 opcode 无效&lt;/li&gt;
&lt;li&gt;中断 interrupt：和指令流异步的外部事件，比如鼠标点击。标准中断源有 3 个&lt;ul&gt;
&lt;li&gt;软件 software：通过写入一个内存映射寄存器触发，通常用于一个 hart 通知另一个 hart，此机制在其他架构中称为处理器间中断 interprocessor interrupt&lt;/li&gt;
&lt;li&gt;时钟 timer：mtime &amp;gt;= mtimecmp（内存映射寄存器）时触发&lt;/li&gt;
&lt;li&gt;外部来源 external：由 PLIC（大部分外设都挂载在它上面）产生，PLIC 因平台而异&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RISC-V 允许不对齐访存，但是仍包含访存地址不对齐异常。原因是考虑到不对齐访存的硬件实现较复杂，且出现频率很低，因此一些硬件实现方案选择不支持不对齐的普通访存操作。这类处理器需要陷入异常处理程序，然后通过一系列较小的对齐访存操作，来在软件中模拟不对齐访存。应用程序代码对此一无所知：不对齐访存操作仍然正确执行，虽然执行得慢，但硬件实现却很简单。此外，高性能处理器亦可在硬件中实现不对齐访存。&lt;/p&gt;
&lt;h3 id="_19"&gt;机器模式的异常处理&lt;/h3&gt;
&lt;p&gt;异常处理必须的 8 个 csr：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;全拼&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mstatus&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Status&lt;/td&gt;
&lt;td&gt;维护各种状态，如全局中断使能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Interrupt Pending&lt;/td&gt;
&lt;td&gt;记录当前的中断请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mie&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Interrupt Enable&lt;/td&gt;
&lt;td&gt;维护处理器的中断使能状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mcause&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Exception Cause&lt;/td&gt;
&lt;td&gt;指示发生了何种异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mtvec&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Trap Vector&lt;/td&gt;
&lt;td&gt;存放发生异常时处理器跳转的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mtval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Trap Value&lt;/td&gt;
&lt;td&gt;存放当前自陷相关的额外信息，如地址异常的故障地址、非法指令异常的指令，发生其他异常时其值为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mepc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Exception PC&lt;/td&gt;
&lt;td&gt;指向发生异常的指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mscratch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Scratch&lt;/td&gt;
&lt;td&gt;向异常处理程序提供一个字的临时存储&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;M-mode 响应 exception 的例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先检查条件 mstatus.MIE = 1，mie 和 mip 的 bit 位，满足条件后原子性地完成以下步骤&lt;/li&gt;
&lt;li&gt;将 exception 指令的 PC 保存到 mepc，然后把 PC 设置为 mtvec&lt;ul&gt;
&lt;li&gt;对于 synchronous exception：mepc 指向触发 exception 的指令&lt;/li&gt;
&lt;li&gt;对于 interrupt：mepc 指向 ISR 后恢复执行的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把 exception 原因写入 mcause，并把故障地址或其他相关信息写入 mtval&lt;/li&gt;
&lt;li&gt;把 MIE 的旧值保存到 MPIE，把 mstatus.MIE 清零以屏蔽 interrupt&lt;/li&gt;
&lt;li&gt;把 exception 发生前的模式保存到 mstatus.MPP，然后把模式更改为 M&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;CSR 中没有记录当前的 privilege 等级，只有 MPP、SPP、UPP，所以软件无法查询得知当前处于哪个模式，原因是 ISA 认为软件开发人员应该准确地知道每段代码所处的特权等级，无需查询。
从硬件设计的角度，内部需要有一个寄存器来记录当前状态，否则无法判断当前等级是否有权限执行某些指令。该内部寄存器未开放给软件，所以在 ISA CSR 中也不可见。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;mscratch 的作用：提供一种快速的保存 - 恢复机制，可以直接把某个 XRF 写入到 mscratch，而不是 stack 中。如果需要保存更多的寄存器，一般 mscratch 指向一片空闲的内存，ISR 可以根据需求把想要的任意个寄存器内容写入到该空间：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先用 csrrw 指令交换 mscratch 和 a0 的内容（mscratch 是 csr，普通指令无法直接使用，必须先交换到 XRF 中。因为 ISR 没有参数，所以 a0 是空闲 XRF，可以用来和 mscratch 交换）&lt;/li&gt;
&lt;li&gt;将任意个 XRF 保存到内存中&lt;/li&gt;
&lt;li&gt;中断处理&lt;/li&gt;
&lt;li&gt;处理完后再从内存中恢复数据到 XRF&lt;/li&gt;
&lt;li&gt;用 csrrw 交换 mscratch 和 a0，恢复内容&lt;/li&gt;
&lt;li&gt;用 mret 返回&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# example：timer 中断的 ISR。&lt;/span&gt;
&lt;span class="c1"&gt;# 假设&lt;/span&gt;
&lt;span class="c1"&gt;# 1. mstatus.MIE=1 已打开全局中断使能&lt;/span&gt;
&lt;span class="c1"&gt;# 2. timer 中断使能 mie[7]=1 已打开&lt;/span&gt;
&lt;span class="c1"&gt;# 3. mtvec 设置为本处理程序的地址&lt;/span&gt;
&lt;span class="c1"&gt;# 4. mscratch 指向一段 16Byte 的临时缓冲区&lt;/span&gt;

&lt;span class="c1"&gt;# step1. 交换 mscratch 和 a0。a0 保持空闲内存供后续普通指令使用，mscratch 保存 a0 旧值，用于后续恢复&lt;/span&gt;
&lt;span class="nf"&gt;csrrw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mscratch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;

&lt;span class="c1"&gt;# step2. 保存 XRF 到空闲内存。因为后续要使用到 a1, a2, a3, a4 这几个 XRF，所以先保存旧值&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# step3. 中断处理&lt;/span&gt;
&lt;span class="c1"&gt;# 解析中断原因&lt;/span&gt;
&lt;span class="nf"&gt;csrr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mcause&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# 读出异常原因&lt;/span&gt;
&lt;span class="nf"&gt;bgez&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;exception&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;# 若非中断则跳转，bgez 的 rs 是 signed 类型，中断对应的 MSB = 1 为负数&lt;/span&gt;
&lt;span class="nf"&gt;andi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0x3f&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# 单独取出中断原因&lt;/span&gt;
&lt;span class="nf"&gt;li&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="c1"&gt;# a2 = 时钟中断号&lt;/span&gt;
&lt;span class="nf"&gt;bne&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;otherInt&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;# 若非 timer 中断则跳转&lt;/span&gt;
&lt;span class="c1"&gt;# 处理 timer 中断，递增 mtimecmp&lt;/span&gt;
&lt;span class="nf"&gt;la&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mtimecmp&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# mtimecmp 是 memory map csr，读出该地址的到 a1&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 读出 mtimecmp 的低 32bit 到 a2&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 读出 mtimecmp 的高 32bit 到 a3&lt;/span&gt;
&lt;span class="nf"&gt;addi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# 给 mtimecmp 的低 32bit 加上 1000，求和结果保存到 a4&lt;/span&gt;
&lt;span class="nf"&gt;sltu&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# 计算进位，如果和 a4 比加数 a2 小，说明有进位，进位保存在 a2 中&lt;/span&gt;
&lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# 把进位加到 mtimecmp 的高位 a3 上&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 保存递增后的 mtimecmp 高位&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 保存递增后的 mtimecmp 低位&lt;/span&gt;

&lt;span class="c1"&gt;# step4. 恢复 XRF, a1, a2, a3, a4&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# step5. 恢复 a0 和 mscratch 旧值&lt;/span&gt;
&lt;span class="nf"&gt;csrrw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mscratch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;

&lt;span class="c1"&gt;# step6. 从 ISR 返回&lt;/span&gt;
&lt;span class="nf"&gt;mret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_20"&gt;嵌入式系统中的用户模式和进程隔离&lt;/h3&gt;
&lt;p&gt;并非所有代码都是可信任的：底层 OS 代码可行度较高，可以访问所有硬件资源；应用程序代码可行度较低，需要进行限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制 U 模式代码可执行的指令（M 模式指令）和访问的资源（M 模式 CSR）&lt;/li&gt;
&lt;li&gt;限制 U 模式代码只能访问各自的内存，即 PMP（指定哪些内存可以让 U 模式访问）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_21"&gt;现代操作系统的监管模式&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id="_22"&gt;页式虚拟内存&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id="_23"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一项又一项的研究表明，最优秀的设计师能更轻松地设计出更快、更小、更简洁、更明了的结构。伟大和平凡之间相差近一个数量级。&lt;/p&gt;
&lt;p&gt;—— 弗雷德 · 布鲁克斯（Fred Brooks, Jr.）, 1986.&amp;gt; 一款指令集的 7 个评价标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成本&lt;/li&gt;
&lt;li&gt;简洁&lt;/li&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;li&gt;架构和实现分离&lt;/li&gt;
&lt;li&gt;提升空间&lt;/li&gt;
&lt;li&gt;代码大小&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;围绕这 7 个评价指标从全系统角度向读者介绍 RISC-V 的精巧设计和众多的取舍考量。&lt;/p&gt;</content><category term="RISC-V"></category><category term="RISC-V"></category><category term="Spec"></category></entry><entry><title>RISC-V Spec 阅读笔记 #2 —— Privileged ISA</title><link href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-2-privileged.html" rel="alternate"></link><published>2021-03-25T17:29:00+08:00</published><updated>2021-03-25T17:29:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2021-03-25:/posts/risc-v/risc-v-spec-notes-2-privileged.html</id><summary type="html">&lt;p&gt;Volume II: Privileged ISA 读书笔记&lt;/p&gt;</summary><content type="html">&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Privileged ISA 文档的版本号 :20190608-Priv-MSU-Ratified&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Unprivileged 的补集，包含了运行操作系统和支持外设所需要的特权指令、额外功能。&lt;/p&gt;
&lt;h3 id="software-stack-terminology"&gt;Software Stack Terminology&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ABI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Application Binary Interface, ABI = user-level ISA + ABI calls to AEE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SBI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Supervisor Binary Interface, SBI = user-level + supervisor-level ISA + SBI calls to SEE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HBI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Hypervisor Binary Interface, HBI = user-level ISA + HBI calls to HEE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;AEE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Application Execution Environment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HEE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Hypervisor Execution Environment&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;观察 spec 中的示意图，可以发现整个 stack 的结构本质上就是不断套娃的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最简单是 “ 裸机系统 ”&lt;/p&gt;
&lt;p&gt;ABI 作为中间抽象借口，隐藏了底层 AEE 的实现细节，对上面的 Application 提供了一个标准抽象借口，这样上层的 Application 就不需要再关心底层实现，这样 AEE 的实现可以更灵活，可以直接用 RISC-V 硬件实现，也可以是一个运行在其他架构机器上的模拟器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套第一层娃，支持单操作系统&lt;/p&gt;
&lt;p&gt;在 ABI 和 AEE 之间插入一层 OS，Application 和 OS 之间通过 ABI 交互，OS 和 SEE 之间通过 SBI 交互。同理，SEE 的实现也可以是真实的硬件，也可以是 hypervisor 提供的虚拟机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套第二层娃，虚拟机支持多操作系统&lt;/p&gt;
&lt;p&gt;在 OS 和 SEE 之间再插入新的一层 hypervisor，每个 OS 通过 SBI 和 hypervisor 交互，hypervisor 通过 HBI 和底层的 HEE 交互。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个 stack 的核心思想可以总结为：&lt;strong&gt;通过抽象的 Interface 对上层提供统一标准借口，隔离底层细节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RISC-V 的硬件不仅要实现 Privileged ISA，还要包含一些其他功能才能完整支持各种执行环境（AEE、SEE、HEE）。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;大部分的 supervisor-level ISA 在定义的时候，都没有把 SBI 从 execution environment 或者是硬件平台中分离出来，这样会导致虚拟化和开发新硬件平台时变得更复杂。&lt;/p&gt;
&lt;p&gt;目前 RISC-V 的 ABI、SBI、HBI 都还在定义中。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="privilege-levels"&gt;Privilege Levels&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别&lt;/th&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;User/Application&lt;/td&gt;
&lt;td&gt;&lt;code&gt;U&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;Supervisor&lt;/td&gt;
&lt;td&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;-Reserved-&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;Machine&lt;/td&gt;
&lt;td&gt;&lt;code&gt;M&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一共定义了 3 个特权层次，其中 M 是强制要求所有实现都必须支持的，M 的层次最高，它可以不受限制地访问底层的完整硬件资源，一般最简实现只支持 M 即可。U 模式是为了支持传统的 Application，S 模式则是为了支持 OS。&lt;/p&gt;
&lt;p&gt;每个 level 都会有一组核心 Privileged ISA，再附加一些可选的扩展指令和变种指令。任何一个实现可以根据资源和目标折中选择支持 3 种 level 的组合。这些 level 是通过 CSR 来定义的，任何一个 hart 任何时候必然处于 3 种 level 中的某一种。&lt;/p&gt;
&lt;p&gt;允许的组合：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别数量&lt;/th&gt;
&lt;th&gt;支持的模式&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;简单嵌入式系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;M, U&lt;/td&gt;
&lt;td&gt;带安全功能的嵌入式系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;M, S, U&lt;/td&gt;
&lt;td&gt;运行 Unix-like 的操作系统&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="debug-mode"&gt;Debug Mode&lt;/h3&gt;
&lt;p&gt;Debug 可以看做是一个比 M 模式级别更高的特权模式，可能会有一些专用的 CSR 和地址空间。RISC-V 的 debug 模式定义在另外一个标准文档中。&lt;/p&gt;
&lt;h2 id="control-and-status-registers-csrs"&gt;Control and Status Registers (CSRs)&lt;/h2&gt;
&lt;p&gt;RISC-V 中的 opcode = &lt;code&gt;SYSTEM&lt;/code&gt; 的字段用来编码特权指令，这些指令可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zicsr&lt;/code&gt; 子集中定义的 atomically read-modify-write CSR 的指令 ( 即 CSR 指令 )&lt;/li&gt;
&lt;li&gt;privileged 中定义的其他指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了 Unprivileged ISA 中描述的 CSR 之外，一个实现还可以包含一些其他 CSR，这些 CSR 在某些特权级别下可以通过 Zicsr 中的指令进行访问。因为特权分了等级，而 CSR 一般和特权等级是一一对应的，所以 CSR 也可以划分等级，可以被同级或更高级别的特权指令访问。&lt;/p&gt;
&lt;h3 id="address-mapping-conventions"&gt;Address Mapping Conventions&lt;/h3&gt;
&lt;p&gt;CSR 的编址使用独立的 12bit 空间，所以理论上最多可以编码 4096 个 CSR。一般的惯例是，最高的 4bit 用来编码 CSR 的读写属性，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;csr[11:10]&lt;/code&gt; 表示 CSR 的读写属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;csr[9:8]&lt;/code&gt; 表示可以访问该 CSR 的最低特权等级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的地址映射区间查 spec 即可。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;出现下列情况，都会抛出一个非法指令的异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问一个不存在的 CSR&lt;/li&gt;
&lt;li&gt;访问的特权等级不够高&lt;/li&gt;
&lt;li&gt;对一个 RO 类型的 CSR 进行写操作&lt;/li&gt;
&lt;li&gt;M 模式下访问 debug CSR 地址段的 CSR&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个 R/W 类型的 CSR 的某些字段可能是 RO 类型，对这些字段的写操作应该被忽略掉。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;所有的 CSR 可以分类两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;user-level CSR：包括 timer、counter、FP CSR 和 N 子集添加的 CSR&lt;/li&gt;
&lt;li&gt;Privileged CSR：剩余的 CSR&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="field-specifications"&gt;Field Specifications&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WPRI&lt;/code&gt; Reserved Write Preserve, Read Ignore&lt;/td&gt;
&lt;td&gt;某些保留的 RW 字段，写入其他字段时保留本字段的原值，读出时软件应该忽略返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WLRL&lt;/code&gt; Write/Read only Legal&lt;/td&gt;
&lt;td&gt;某些 RW 字段只有部分取值合法，软件不能写非法值，只有写入合法值后才能假设读回值合法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WARL&lt;/code&gt; Write Any, Read Legel&lt;/td&gt;
&lt;td&gt;某些 RW 字段只有部分取值合法，但是允许写入任何值，读出时返回合法值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;为了保持前向兼容，不提供 WPRI 字段的实现时应该把这些字段 tie 0&lt;/li&gt;
&lt;li&gt;给 WLRL 字段写入非法值，实现可以自行决定是否抛出非法指令异常，当写入非法值后，读出值可以是任意值，但是必须保持确定性&lt;/li&gt;
&lt;li&gt;给 WARL 字段写入非法值，实现不应该抛出异常，但是写入非法值后，必须保持读出值的确定性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="machine-level-isa"&gt;Machine-Level ISA&lt;/h2&gt;
&lt;p&gt;M-mode 的特权等级最高，而且是唯一强制要求实现模式，它用于访问底层硬件，是上电复位后进入的第一个模式。M-mode 包含一个可扩展的核心 ISA，具体实现可以根据支持的特权等级和自身的硬件特性来扩展它。&lt;/p&gt;
&lt;h3 id="machine-level-csrs"&gt;Machine-Level CSRs&lt;/h3&gt;
&lt;p&gt;略。&lt;/p&gt;
&lt;h3 id="machine-mode-privileged-instructions"&gt;Machine-Mode Privileged Instructions&lt;/h3&gt;
&lt;p&gt;一共 6 条，可以分成 3 类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;系统调用&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ECALL&lt;/code&gt;, &lt;code&gt;EBREAK&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Trap 返回&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MRET&lt;/code&gt;, &lt;code&gt;SRET&lt;/code&gt;, &lt;code&gt;URET&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WFI&lt;/td&gt;
&lt;td&gt;&lt;code&gt;WFI&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="reset"&gt;Reset&lt;/h3&gt;
&lt;p&gt;一旦复位，要满足下面要求，除此之外的状态不做要求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hart 必须处于 M-mode，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mstatus&lt;/code&gt; 的 &lt;code&gt;MIE&lt;/code&gt; 和 &lt;code&gt;MPRV&lt;/code&gt; 字段要复位成 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;misa&lt;/code&gt; 字段要复位到支持的最大子集和最宽的 &lt;code&gt;MXLEN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pc&lt;/code&gt; 要复位到实现预先定义好的 reset vector&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mcause&lt;/code&gt; 要保存导致复位的原因&lt;/li&gt;
&lt;li&gt;PMP 的 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;L&lt;/code&gt; 字段设置为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="nmi"&gt;NMI&lt;/h3&gt;
&lt;p&gt;Non-Maskable Interrupts 的作用是发生硬件错误时，不管中断使能是否打开，直接跳转到预先定义好的 NMI vector，在 M-mode 下运行。&lt;code&gt;mepc&lt;/code&gt; 保存发生 NMI 的下一条指令；&lt;code&gt;mcause&lt;/code&gt; 保存导致 NMI 的原因，具体值由实现自定义，但是 0 表示 unknown，所以如果实现不关心 NMI 的原因，那么直接保存 0 即可。&lt;/p&gt;
&lt;h3 id="pma"&gt;PMA&lt;/h3&gt;
&lt;p&gt;一个完整系统中的地址空间包含了各种各样的地址段，有些是真实的 memory 域，有些是 memory-mapped 的 control register，还有些是空洞段。有些 memory 域不支持读 / 写 / 执行，有些不支持 subword/sublock 的访问，有些不支持原子性操作，有些不支持 cache 一致性协议或是 memory 模型不一样。同理，memory map 的控制寄存器在访问位宽、是否支持原子操作、以及 read/write 访问是否有副作用等方面也各不相同。在 RISC-V 系统中，这些属性有一个专门的术语 &lt;code&gt;Physical Memory Attributes (PMAs)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PMA 是硬件的固有属性，所以在系统运行时很少变化。&lt;/strong&gt;和 PMP 不同，PMA 很少会随着运行程序的上下文来改变状态。有些 memory region 的 PMA 属性在硬件设计时就已经确定了，比如片上 ROM。另外一些在 board design 时确定，比如片外总线上挂载的是什么芯片。片外总线上可以挂载一些支持冷 / 热拔插的设备。某些设备可以在运行时支持重配置，以支持不同用户设置不同的 PMA 属性，比如，一个片上 RAM 可以在一个应用中被配置为私有空间，也可以在另外一个应用中被配置为共享空间。&lt;/p&gt;
&lt;p&gt;大部分系统都要求硬件在知道物理地址之后做一些必要的 PMA 检查，比如有些物理地址不支持某些特定操作，而有些操作需要提前知道 PMA 的正确配置值。虽然某些架构是在 virtual page 中声明 PMA，然后通过 TLB 来通知 pipeline 这些信息，但是这个方法会将一些底层的平台些信息注入到上层的 virtual layer，而且一旦某个 page table 中的某个 memory region 配置不对，就会导致系统错误。此外，可变的 page size 对于 PMA 来说并不是最优选择，会导致地址空间碎片和 TLB 的低效率使用。&lt;/p&gt;
&lt;p&gt;RISC-V 则把 PMA 的标准独立出来，并且用一个独立的硬件 PMA checker 来检查 PMA：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大部分情况下，PMA 属性是在芯片设计时就已经确定了的，所以可以直接在 checker 中以硬连线的方式实现&lt;/li&gt;
&lt;li&gt;对于 runtime 可配置的 PMA，则可以通过一些 memory mapped control register 来实现（比如片上 SRAM 可以动态地划分为 cacheable/uncacheable 区域）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了帮助 debubg，协议强烈建议，只要有可能，就应该精确地捕获导致 PMA 检查失败的物理地址访问。为了正确地访问设备或者是控制其他硬件单元（比如 DMA）去访问 memory，PMA 对软件来说必须是可读的。&lt;/p&gt;
&lt;p&gt;对于 platform 支持的可配置 PMA，应该提供一个接口，传递运行在 machine mode 下的 driver 请求，实现正确配置。比如，切换某些 memory region 的 cacheability 时，会触发一些特定操作，比如 cache flush，这些操作一般都只能在 machine mode 下进行。&lt;/p&gt;
&lt;p&gt;PMA 大概包含下面几方面。&lt;/p&gt;
&lt;h4 id="main-memory-io-empty"&gt;Main memory / IO / empty&lt;/h4&gt;
&lt;p&gt;对于一个地址段来说，最重要的属性就是它映射的是 main memory，还是 I/O 设备，还是空地址段。&lt;/p&gt;
&lt;p&gt;main memory 会有一些属性，而 I/O 设备的属性会更广泛一些，而空地址段会被归类为 I/O 空间，但是不支持访问。&lt;/p&gt;
&lt;h4 id="supported-access-type"&gt;Supported Access Type&lt;/h4&gt;
&lt;p&gt;另外一个属性是访问类型：访问的位宽以及每种位宽下是否支持非对齐访问。&lt;/p&gt;
&lt;p&gt;main memory 永远都支持所有 device 要求的所有 width 下的 read/write/execute 操作。I/O 空间则可以在 R/W/E 和位宽之间做选择。&lt;/p&gt;
&lt;h4 id="atomicity"&gt;Atomicity&lt;/h4&gt;
&lt;p&gt;PMA 还需要描述每个地址段支持哪些原子指令。main memory 必须支持所有的原子指令，I/O 域可能只支持部分原子操作。&lt;/p&gt;
&lt;h4 id="memory-ordering"&gt;Memory-Ordering&lt;/h4&gt;
&lt;p&gt;将地址空间分为 main memory 和 I/O 两种类型的目的是为了支持 FENCE/AMO 中定义的访问顺序。&lt;/p&gt;
&lt;p&gt;一个 hart 对 main memory 的访问不仅会被其他 hart 观测到，同时也会被其他可以给 main memory 发送请求的设备（比如 DMA）观测到。main memory 空间要么是 RVWMMO 模型，要么是 RVTSO 模型。&lt;/p&gt;
&lt;p&gt;一个 hart 对 I/O 空间的访问不经会被其他 hart 和总线上的 master 设备观测到，还会被目标 slave 设备观测到。&lt;/p&gt;
&lt;h4 id="coherenece-and-cacheability"&gt;Coherenece and Cacheability&lt;/h4&gt;
&lt;p&gt;coherenece 是针对单个物理地址而言的属性，表示某个 agent 对该地址的访问对系统中的其他 agent 可见。注意，不要混淆 coherence 和内存一致性模型。RISC-V 中不鼓励使用 hardware incoherent region，因为它会导致软件复杂化，性能和功耗恶化。&lt;/p&gt;
&lt;p&gt;一个地址段的 cacheability 属性不会改变软件对该地址段的 view，这些 view 不包括其他 PMA 中规定的属性（比如 main memory 和 I/O 空间的划分、访问顺序、支持的访问类型、支持的原子操作、coherence 等）。&lt;/p&gt;
&lt;p&gt;一些 platform 支持某些地址段的 cacheability 可配，这种情况下，由某个 machine mode 下的 routine 对 cacheability 进行配置，并在必要时 flush cache。&lt;/p&gt;
&lt;h4 id="idempotency"&gt;Idempotency&lt;/h4&gt;
&lt;p&gt;幂等性 idempotency：执行多次和一次的效果一样。&lt;/p&gt;
&lt;p&gt;许多 main memory region 都被认为是 idempotent。对 I/O region，read/write 的 idempotent 是分开的：read 具有幂等性，而 write 不具有。&lt;/p&gt;
&lt;p&gt;如果访问不具有幂等性，也就是说会产生潜在的副作用，那么 speculative 和 redundant 的访问都必须被规避掉（因为他们都可能会导致多次访问）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main memory 是 idempotency（执行多次和一次效果一样）；I/O 域的 read 是 idempotent 的，而 write 不是&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="pmp"&gt;PMP&lt;/h3&gt;
&lt;p&gt;为了支持安全功能，需要通过软件的方式限制物理地址的访问属性，这个需求可以通过一个可选的 &lt;code&gt;Physical Memory Protection (PMP)&lt;/code&gt; 单元实现，它可以为每个 hart 提供每个 memory region 的访问属性控制寄存器。PMP 和 PMA 是并列关系，同步进行检查。&lt;/p&gt;
&lt;p&gt;虽然 PMP 的访问粒度是和平台相关的，而且平台中不同地址段的粒度也会不同，但是标准的 PMP 编码支持的最小段大小为 4 Byte。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;不同平台对 PMP 的需求是不同的，有些平台还会提供其他的 PMP 指令来增强 / 代替标准中描述的方案。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;当 core 运行在 S 或者 U 模式时，PMP checker 会检查所有的访问。&lt;/p&gt;
&lt;h4 id="pmp-csrs"&gt;PMP CSRs&lt;/h4&gt;
&lt;p&gt;RISC-V 最多支持 16 个 PMP entries，每个 entry 由一个 8bit 的配置寄存器 &lt;code&gt;pmpcfg&lt;/code&gt; 和一个 MXLEN 的地址寄存器 &lt;code&gt;pmpaddr&lt;/code&gt; 定义。只要实现了任何一个 PMP entry，那么就要实现所有的 PMP CSRs，这些 CSR 的属性是 WARL，所以可以在硬件上直接 tie-0，而且只能在 M-mode 层级访问。&lt;/p&gt;
&lt;p&gt;为了最小化上下文切换的代价，&lt;code&gt;pmpcfg&lt;/code&gt; 是按照小端模式密集存储在一起的。所以可以算出来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RV32 需要 4 个 csr 来存储配置信息 &lt;code&gt;pmpcfg0&lt;/code&gt; ~ &lt;code&gt;pmpcfg3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RV64 需要 2 个 csr 保存配置信息 &lt;code&gt;pmpcfg0&lt;/code&gt;, &lt;code&gt;pmpcfg2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个 pmpcfg 规定了对应 pmpaddr 中那段地址的属性：R/W/X 以及如何解释（使用） &lt;code&gt;pmpaddrx&lt;/code&gt; 的内容，即如何确定该 entry 的起始地址和大小。具体来说是通过 pmpcfg.A 字段联合 pmpaddr 中的低位 bit 共同确定。原理也很简单，对于某段按照 2 的幂次对齐的地址，其实低位是冗余的，所以可以用这些低位来表示对齐基数。&lt;/p&gt;
&lt;p&gt;若地址为 &lt;code&gt;yyy...y01...1&lt;/code&gt; 这种形式，且低位连续 1 的位数为 n，那么对齐基数就是 &lt;span class="math"&gt;\(2^{n+3}\)&lt;/span&gt; Byte（因为 pmpaddr 是从物理地址的 bit[2] 开始存储，所以 bit[1:0] 天然为 0，这也符合 RV32 的最小访问粒度 32bit = 4Byte）。&lt;/p&gt;
&lt;h4 id="pmp-and-paging"&gt;PMP and Paging&lt;/h4&gt;
&lt;p&gt;设计 PMP 机制的主要目的是实现基于 page 技术的 Virtual-Memory 系统。&lt;/p&gt;
&lt;h2 id="supervisor-level-isa"&gt;Supervisor-Level ISA&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="RISC-V"></category><category term="RISC-V"></category><category term="Spec"></category></entry><entry><title>RISC-V Spec 阅读笔记 #1 —— Unprivileged ISA</title><link href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-1-unprivileged.html" rel="alternate"></link><published>2020-11-17T21:55:00+08:00</published><updated>2020-11-17T21:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-11-17:/posts/risc-v/risc-v-spec-notes-1-unprivileged.html</id><summary type="html">&lt;p&gt;Volume I: Unprivileged ISA 读书笔记&lt;/p&gt;</summary><content type="html">&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Unprivileged ISA 文档的版本号 :20191213&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;RISC-V 的目标可以说非常宏大、也非常务实，可以用这几个关键词来概括：完全 open、可实现、通用、模块化、可扩展。RISC-V 在定义时尽可能地规避了具体的实现细节（虽然 ISA 中有些设计是出于实现考虑的），所以这个 ISA 应该当成各种不同实现方案的统一软件可见接口，而非某种特定微架构实现的专属。整个手册分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Volume I: Unpriviledge ISA&lt;/li&gt;
&lt;li&gt;Volume II: Priviledge ISA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在设计这些 ISA 时都遵循了 “ 尽量移除对特定微架构依赖 ” 的原则，这样可以在简化 ISA 同时保证实现最大程度的灵活性。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;ISA 作为软件和硬件之间的接口，其地位非常重要。曾经有很多各种各样的 ISA，其中大部分都随着历史消亡了，只剩下个别占领了市场主流，并不断演进。但是目前大部分 ISA 被商业产权保护，普通人无法使用，而且因为要向后兼容而有历史包袱，在这样的背景下，RISC-V 最早起源于 UC Berkeley 的教学需求，逐渐发展壮大，如今在业界如火如荼。&lt;/p&gt;
&lt;p&gt;定义一个新的 ISA 并不是简单定义指令集就足够的，还需要大量的投入，比如文档、编译器工具链、测试套件、教学材料等等，即使这些都全做出来了别人也不一定会用，做出来简单，要想推动整个生态是件非常难的事情。看看 RISC-V 基金的董事会和赞助商，就会发现全是著名科技公司和大佬，也只有他们才能集整个产业届的力量推动新的 ISA 发展。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;ISA 之所以叫架构，是因为它作为软硬件世界之间的桥梁，不仅仅包含了指令集，还需要包含很多其他内容，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据类型&lt;/li&gt;
&lt;li&gt;存储模型&lt;/li&gt;
&lt;li&gt;软件可见的处理器状态 GPR + CSR + PC&lt;/li&gt;
&lt;li&gt;指令集&lt;/li&gt;
&lt;li&gt;系统模型：状态 + 特权级别  + 中断 / 异常&lt;/li&gt;
&lt;li&gt;外部接口： I/O + 管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hardware-platform-terminology"&gt;Hardware Platform Terminology&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hardware platform&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RISC-V core + non-RISC-V core + accelerator + memory + I/O + interconnect&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;core&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含独立的 IFU 的模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;coprocessor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;附着在 RISC-V core 上，由 RISC-V 指令流控制，具有有限的自主控制权运行自己的扩展指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;accelerator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不可编程的固定函数单元 / 针对特定功能的可以自动运行的 core&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="software-execution-environment-and-harts"&gt;Software Execution Environment and Harts&lt;/h3&gt;
&lt;p&gt;RISC-V 程序的行为依赖于它的执行环境，&lt;code&gt;EEI (Execution Environment Interface)&lt;/code&gt; 定义了下面这些内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序的初始状态&lt;/li&gt;
&lt;li&gt;Hart 的数量和类型&lt;/li&gt;
&lt;li&gt;hart 支持的特权模式&lt;/li&gt;
&lt;li&gt;memory/IO 的访问及特性&lt;/li&gt;
&lt;li&gt;所有合法指令的行为&lt;/li&gt;
&lt;li&gt;中断和异常的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EEI 的典型例子有 Linux 的 &lt;code&gt;ABI (Application Binary Interface)&lt;/code&gt; 和 RISC-V 的 &lt;code&gt;SBI (Supervisor Binary Interface)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;EEI 的实现方式有多种：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实现方式&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Bare metal&lt;/td&gt;
&lt;td&gt;hart 由硬件直接实现，指令可以访问所有的物理地址空间，硬件平台定义上电复位后的执行环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;通过对处理器和 memory 的控制，不同用户级的 hart 复用有限的物理处理器线程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;管理程序&lt;/td&gt;
&lt;td&gt;对 guest 访问提供不同层级的执行环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;仿真器&lt;/td&gt;
&lt;td&gt;在另一个硬件平台（如 x86）上模拟 RISC-V 的 hart，比如 Spike、QEMU、rv8 等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Hardware Thread&lt;/code&gt;：随着处理器技术的发展，现在的处理器已经突破了多核的概念，在单个核心中包含多个硬件线程的技术叫做硬件超线程 &lt;code&gt;Hyper-threading&lt;/code&gt;，每个硬件线程有自己独立的 RF 等上下文资源，但是不同线程共享同一份运算资源，所以面积效率很高。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hart&lt;/code&gt;：为了区别多核，RISC-V 定义的术语，取 Hardware Thread 之意，包含自动取指和执行所涉及的硬件资源的统称。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="isa-overview"&gt;ISA Overview&lt;/h3&gt;
&lt;p&gt;RISCV ISA 由必选的 Base Integer ISA 和其他可选 ISA 组成，完整的子集列表直接看 spec 即可。其中必选的 base interger ISA 和以前的 RISC 处理器的 ISA 非常相似，只是去掉了分支延迟槽和可选的变长编码，一共有 4 种形式，它们的区别在于 register 的位宽、register 的数量、寻址空间大小： &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ISA&lt;/th&gt;
&lt;th&gt;XLEN (register 位宽 )&lt;/th&gt;
&lt;th&gt;registe 数量&lt;/th&gt;
&lt;th&gt;寻址空间范围 (Byte)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RV32I&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{32}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV64I&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{64}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV32E&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{32}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV128I&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{128}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;4 个 base ISA 被当作完全不同的 ISA 来对待，所以有个常见问题：&lt;/p&gt;
&lt;p&gt;Q：为什么不设计一个统一的 ISA，即让 RV32I 是 RV64I 的子集？一些早期 ISA(SPARC, MIPS) 就采用了这样的设计规则，使得可以在 64bit 的硬件上运行 32bit 的程序。&lt;/p&gt;
&lt;p&gt;A：ISA 分开设计的优点是可以针对某个子集独立优化，不需要为支持其他子集而消耗资源，缺点则是在一个 ISA 上仿真另外一个 ISA 会硬件会更复杂。实际上寻址模式和捕获非法指令的不同往往意味着即使某两个 ISA 是子集关系仍然需要两套电路以及某种模式切换，而且 RISC-V 的 base ISA 之间的相似性可以降低多版本的开销。虽然理论上可以把 32bit 的 lib 和 64bit 的代码链接在一起，但因为程序调用和系统调用接口的不同实际中并不可行。&lt;/p&gt;
&lt;p&gt;RISC-V 的特权架构中 misa 寄存器有个字段专门用来控制在同一份电路上如何模拟不同的 base ISA，而且可以看到 SPARC 和 MIPS 也放弃了对在 64bit 系统上直接运行 32bit 程序的支持。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="memory"&gt;Memory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;memory 地址是循环的，最大的地址溢出后自动回到 0 地址，硬件计算地址时会自动忽略溢出&lt;/li&gt;
&lt;li&gt;一般地址空间被分成了不同段，访问不允许的地址应该报 exception&lt;/li&gt;
&lt;li&gt;RISC-V 默认使用 &lt;code&gt;RVWMO(RISC-V Weak Memory Ordering)&lt;/code&gt; 作为内存一致性模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="base-isa-encoding"&gt;Base ISA Encoding&lt;/h3&gt;
&lt;p&gt;RISC-V 指令可以是变长的，但是所有 base ISA 都按照 16bit 对齐，即其指令长度都是 16bit 的倍数。&lt;/p&gt;
&lt;p&gt;使用术语 &lt;code&gt;IALIGN&lt;/code&gt; 表示指令对齐约束，IALIGN 的取值只能是 16 或 32：base ISA 的 IALIGN 是 32，C 子集和其他扩展 ISA 可以是 16。使用术语 &lt;code&gt;ILEN&lt;/code&gt; 表示某个实现支持的最大指令长度，它永远是 &lt;code&gt;IALIGN&lt;/code&gt; 的整数倍，具体的指令编码格式略。&lt;/p&gt;
&lt;p&gt;Memory 系统既可以是大端模式，也可以是小端模式，但是指令存储一定是以 16bit 为单位的数据包的小端模式。&lt;/p&gt;
&lt;h3 id="exceptions-traps-interrupts"&gt;Exceptions, Traps, Interrupts&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Exception&lt;/code&gt; 表示指令执行中处理器本身出现异常情况而停止执行当前程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Interrupt&lt;/code&gt; 表示外部异步事件导致处理器停止执行当前程序，转而去完成其他事情，完成后再继续之前的程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trap&lt;/code&gt; 表示由 exception 或 interrput 导致的控制权转移到 trap handler&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4 种不同的 trap：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Contained&lt;/th&gt;
&lt;th&gt;Requested&lt;/th&gt;
&lt;th&gt;Invisible&lt;/th&gt;
&lt;th&gt;Fatal&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Execution terminates ?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Software is oblivious?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Handled by environment?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="rv32i-base-isa"&gt;RV32I Base ISA&lt;/h2&gt;
&lt;p&gt;一共有 40 条指令，查询 reference card 即可。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一些资料中会描述说 I 指令集包含 47 条指令，这里有点歧义。以前的历史版本中 I 确实有 47 条指令，但是在最新的版本中，有 7 条指令被移了出来，只剩下只包 40 条指令，通常所说的 47 条指令是把另外两个必要的子集也包含在内：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Zifencei&lt;/code&gt; 子集：包含 1 条指令 &lt;code&gt;FENCE.I&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Zicsr&lt;/code&gt; 子集：包含 6 条 csr 相关的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一些实现中，可能会把 ECALL/EBREAK 当成一条永远 trap 的硬件指令来处理，且把 FENCE 指令当成 NOP 来处理，这时 I 子集的指令条数就缩水到了 38 条。&lt;/p&gt;
&lt;p&gt;除了 A 子集需要特殊的硬件来支持原子性操作之外，RV32I 基本上可以模拟任何其他子集。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="programmers-model"&gt;Programmers' Model&lt;/h3&gt;
&lt;p&gt;程序员可见的寄存器分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器：一共有 32 个，XLEN=32，其中 x0 为常数 0，还有个特殊的 register 即 &lt;code&gt;pc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CSR&lt;/code&gt; 寄存器：control and state register，内部寄存器，专有的 12bit 地址编码空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I 子集只涉及通用寄存器，CSR 寄存器在后面的 &lt;code&gt;Zicsr&lt;/code&gt; 部分介绍。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一个 ISA 中寄存器的个数对代码体积、性能、功耗有巨大的影响。到底应该设计多少个 register 也是有讲究的，有种意见是对于 I 子集只用 16bit 的指令编码 16 个 register 就已经足够了，但是如果指令中包含 3 个寄存器地址，则光地址就需要 12bit，只剩了 4bit 来编码 opcode，这基本上是不可能的。而如果指令只包含 2 个地址，那么实现相同功能就需要更多的指令，降低效率。为了简化硬件设计也应该避免 24bit 这种中间长度的指令格式，所以最终选择了 32bit 的指令来编码 32 个寄存器。寄存器数量多一些对性能提升也有帮助，比如 loop unrolling, software pipelining, cache tiling 这些技术都对寄存器数量有很大的需求。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="format"&gt;Format&lt;/h3&gt;
&lt;p&gt;主要有 4 种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; (Register)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; (Immediate) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; (Store)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U&lt;/code&gt; (Upper)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令长度都是 32bit，按照 4Byte 对齐存储。RISC-V 的指令格式也是精心设计过的，目的就是为了简化硬件的译码电路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同指令中的 rs1, rs2, rd 都在固定位置&lt;/li&gt;
&lt;li&gt;所有指令中的立即数都是按照有符号的方式扩展（除了 CSR 指令中的 5bit 立即数）&lt;/li&gt;
&lt;li&gt;所有立即数都放在指令可用空间的最左边 bit 位置&lt;/li&gt;
&lt;li&gt;所有立即数的符号位都在指令的固定位置，第 31bit&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;译码模块中识别 register 标识符的逻辑通常都是关键路径，所以 RISC-V 在设计指令格式的时候，不管是什么格式类型的指令，都把标识符放在固定位置，付出的代价则是指令中立即数的位置会随着指令类型变化。&lt;/p&gt;
&lt;p&gt;实际上，大部分立即数的位宽要么很小，要么就要占满 XLEN bit，RISC-V 选择了一种非对称的方式切分立即数（用两条指令来搬运一个立即数：第一条指令搬运低 12bit，第二条指令搬运剩余的 20bit），这样做的好处是可以增加常规指令 opcode 的编码空间。&lt;/p&gt;
&lt;p&gt;所有立即数都是符号为扩展的，因为我们没有发现 MIPS 中按 0 扩展能带来什么好处，这样做同时也能最大限度地保持 ISA 的简洁。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;因为立即数的原因，所以有了另外两个变种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; (Branch) 类型：它和 &lt;code&gt;S&lt;/code&gt; 一样都用 12bit 来编码立即数，唯一区别是 B 中的立即数是 S 中立即数的 2 倍，也就是说 S 中的 12bit 表示 imm[11:0]，而 B 中的 12bit 表示 imm[12:1]，而且这 12bit 在指令中的位置是精心设计过的，并不是简单移位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt; (Jump) 类型：它和 &lt;code&gt;U&lt;/code&gt; 的关系也是类似的，唯一区别是 U 和 J 需要 shift 的 bit 位数不一样，同理，立即数的位置是精心设计过的，并不是简单填充&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;立即数的符号位扩展是其关键路径之一，RISC-V 把所有立即数的符号位都放在第 31bit，好处是可以让符号位扩展和译码并行。&lt;/p&gt;
&lt;p&gt;虽然有些复杂的实现会给 branch 和 jump 指令计算分配专有加法器，所以并不会受益于不同指令中的立即数位置固定的设计，但是我们想降低最简实现的硬件成本。通过变换立即数的 bit 位置，而不是使用动态的硬件 mux，指令信号的 fanout 和 mux 数量大概减少为原来的一半。而这种混乱的立即数编码带来的开销可以忽略不计。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;下面分类描述 I 子集的 40 条指令，大概可以分成 4 类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;数量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;计算指令&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;控制转移指令&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Load/Store 指令&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Memory 顺序指令&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统调用和断点&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="integer-computational-instructions"&gt;Integer Computational Instructions&lt;/h3&gt;
&lt;p&gt;计算指令只有两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;I-type&lt;/code&gt;：register 和 immediate 相计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R-type&lt;/code&gt;：register 和 register 相计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两类都会有 rd 寄存器来保存结果，而且都不会产生算术异常。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;我们并没有设计特殊的指令集来检测 overflow，因为可以用 branch 指令很廉价的实现这个功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无符号数加法的 overflow 检查只需要在 add 指令后面加一条 branch 指令即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;add t0, t1, t2
bltu t0, t1, overflw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有符号数加法，如果已知一个操作数的符号（I 类型加法），那么只需要在 add 后面加一条 branch 指令即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;addi t0, t1, +imm
blt t0, t1, overflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于一般的有符号数 R 类型的加法，需要 3 条指令来检测求和结果是否比任何一个加数都小（除非一个操作数是负数）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;add t0, t1, t2
slti t3, t2, 0
slt t4, t0, t1
bne t3, t4, overflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SLTIU&lt;/code&gt; 指令需要先对立即数进行符号位扩展，然后再当成无符号数来比较&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NOP&lt;/code&gt; 是伪指令，以 &lt;code&gt;ADDI x0, x0, 0&lt;/code&gt; 的方式实现&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AUIPC&lt;/code&gt; 指令支持以 “ 双指令序列 ” 的方式访问当前 PC 的任意 offset 位置，可以用来做控制流的转移或者是数据访问，可以访问相对于当前 PC 值的任意 32-bit 地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制流转移： JAL + AUIPC&lt;/li&gt;
&lt;li&gt;数据访问： LOAD/STORD + AUIPC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然获取当前 PC 值可以通过把 AUIPC 的立即数设置为 0 来实现，也可以通过 &lt;code&gt;JAL +4&lt;/code&gt; 的方式实现，但是后者的问题在于可能会导致流水线停顿或者是污染 BTB。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一般 NOP 指令都用来处理地址边界问题以使得指令对齐，或者为指令修改预留空间。虽然 NOP 的实现方式有很多种，我们只定义了一种作为示范，给微架构层面的优化留有空间，同时也可以使得汇编代码的可读性更好。NOP 指令也可以用 HINT 指令来实现。&lt;/p&gt;
&lt;p&gt;选用 ADDI 来实现 NOP 的原因是，这样占用的资源最少（除非是在 decode 阶段把它优化掉了），只需要读一个 register，而且在超标量处理器中加法器是最常见的操作，AGU 可以像计算地址一样直接执行这条指令，其他的 register-register 指令（比如 ADD 或 logical 指令、shift 指令）都需要额外的硬件才能完成。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="control-transfer-instructions"&gt;Control Transfer Instructions&lt;/h3&gt;
&lt;p&gt;控制流相关的指令一共有两类，而且都没有 delay slot（延迟槽），如果跳转地址没有对齐，则会产生一个不对齐异常。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件跳转 jump&lt;/li&gt;
&lt;li&gt;有条件分支 branch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 &lt;code&gt;JAL&lt;/code&gt; 指令属于 J-type，所以它包含了 imm[20:1] bit，所以可以跳转的范围是 [-1MB, +1MB] 内。JAL 会把 (pc+4) 这值存到 rd 中，一般标准的软件调用惯例是 rd = x1 作为返回地址，x5 作为 alternate link register。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;这个 alternate link register 可以在保留常规的返回地址寄存器 rd 的同时支持调用一些代码量非常小的例程，之所以选择 x5 是因为在标准调用中它是一个临时寄存器，而且和 x1 的编码只有 1bit 不同。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;无条件 jump 指令都是使用 PC 的相对地址，以支持和地址不相关的代码。JALR 和 LUI 组合在一起可以访问 32bit 地址空间中的任一位置，首先 LUI 把目标地址的高 20bit 搬运到寄存器中，然后 JALR 把低 12bit 加上去就可以算出完整的 32bit 目标地址。同理，AUIPC 和 JALR 也可以跳转到相对于 PC 的任意 32bit 地址。&lt;/p&gt;
&lt;p&gt;需要注意的是，JALR 不会像 branch 指令一样，从 imm[1] 开始编码（2 的倍数），这样做的好处是可以避免硬件中立即数格式太多的问题。&lt;/p&gt;
&lt;p&gt;JALR 执行的时候，会把计算结果的的最低位清零，这样做的好处是可以稍微简化硬件设计，同时还可以空余出 1bit 空间来存储更多信息。虽然这么做就需要对地址进行错误检查，所以有些轻微的性能损失，如果哦发生了指令地址错误应该很快就触发异常，所以问题不大。&lt;/p&gt;
&lt;p&gt;当 rs1=x0 时，JALR 可以用来实现单指令子程序，在 [-2KB, 2KB] 范围内跳转，可以实现 runtime lib 的快速调用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RAS 预测是高性能 IFU 中的常见功能，但是前提是要能准确区分出函数调用和返回，协议规定了 JAL 和 JALR 所使用的寄存器序号可以用来辅助 RAS 预测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 JAL 的 rd=x1 或者是 rd=x5，那么就是函数调用，要把 rd 寄存器的值 push 进 RAS&lt;/li&gt;
&lt;li&gt;JALR 和 RAS 的行为可以查表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;遵守协议的规定，compiler 和 core 配合就可以最大化地提高 RAS 的预测准确度。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;有些 ISA 使用了特别的 bit 位来标识辅助 RAS，我们使用隐式的方式（约定寄存器号）来减少对编码空间的占用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;所有的 branch 指令都是 B-type，所以它编码了 imm[12:1] bit，所以可以跳转的范围是 [-4KB, 4KB] 之间。&lt;/p&gt;
&lt;p&gt;协议规定软件要假设硬件是 BTFN 算法的方式，依次进行优化，这样可以提高低端 CPU 的预测性能。不同于其他 ISA，RISC-V 规定无条件跳转必须使用 JAL(rd=x0)，而不能用 branch（条件设置为 true）。因为 jump 指令要比 branch 的跳转范围大，而且不会污染条件 branch 的预测表。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;条件 branch 指令被设计成包含两个 register 的算数比较的方式（同 PA-RISC、Xtensa、MIPS R6），没有使用下面的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用条件码 condition code（x86、ARM、SPARC、PowerPC）&lt;/li&gt;
&lt;li&gt;只使用一个 register 和 0 做比较（Alpha，MIPS）&lt;/li&gt;
&lt;li&gt;只有相等比较使用两个寄存器（MIPS）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样设计的主要原因是把比较和分支合并在一起，更加适合常规流水线，不需要使用额外的 condition code，也不需要使用寄存器保存中间结果，可以减少代码体积，降低 IFU 的带宽，还可以在 IF 阶段就被提前检测到，即使是和 0 比较这种设计，也会引入不可忽略的 latency。这样设计付出的硬件代价也很小近似可以忽略。另外融合的指令可以在流水线的上游更早地观测到，更早地预测。&lt;/p&gt;
&lt;p&gt;曾经考虑过在指令中加入静态分支提示，但最终并没有加，虽然静态分支提示可以缓解动态预测器的压力，但是需要占用更多的编码空间，还需要软件做 profiling 才能获得最好的结果，而一旦 profiling 和实际不一致，性能就很差。&lt;/p&gt;
&lt;p&gt;没有包含类似 ARM 条件码的原因是：条件码需要占用指令的额外 bit，需要额外的指令来设置 / 清除，增加了硬件复杂度，而和它一起配合使用的静态预测的效果可能并不好。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="load-and-store-instructions"&gt;Load and Store Instructions&lt;/h3&gt;
&lt;p&gt;RISC-V 是一个 load-store 体系结构，即只有 load/store 才可以访问 memory，计算指令只能和寄存器打交道，而且 RISC-V 的端序是 byte 地址不变的。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 load 指令的 rd 是 x0，即使读回来的数据被丢弃了，也必须报一个任意类型的 exception&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在一个端序是 byte 地址不变的系统中，有下列特性：如果某个 1 byte 的数据被 store 在某种端序的 memory 的某个地址中，那么从那个地址中 load 1 byte 数据返回的数据也是那个值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小端系统：一个多 byte 数据，LSB 被存储在 memory 的低位地址，剩余数据的地址按照顺序递增，load 指令会把低位地址的数据搬运到 register 的 LSB 中&lt;/li&gt;
&lt;li&gt;大端系统：一个多 byte 数据，MSB 被存储在 memory 的低位地中，剩余数据的地址按照顺序递减，load 指令会把高位地址的数据搬运到 register 的 LSB 中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RV32I 的地址空间是 32bit，按照 byte 地址访问，由 EEI 规定合法的地址段。无论端序如何，如果访问地址是天然对齐的，那么就不会产生任何异常，如果访问地址不是天然对齐的（访问数据量是 32bit，地址按照 4byte 对齐；访问数据量是 16bit，地址按照 2byte 对齐），那么具体行为取决于 EEI。EEI 可以允许非对齐访问，由硬件或者软件处理，也可以不允许非对齐访问，直接抛出异常。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;非对齐访问在移植旧代码、使用 packed-SIMD 扩展的应用程序、处理外部打包的数据结构时很有用。之所以通过 load/store 来允许 EEI 自主选择非对其访问的处理方式，目的就是想简化硬件设计。&lt;/p&gt;
&lt;p&gt;有一种备选方案：在 base ISA 中不允许非对齐访问，额外再设计一个 ISA 来支持非对齐访问，比如某些特殊指令或者是硬件特殊的寻址模式。这个方案的问题在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特殊指令使用难度大，导致 ISA 复杂化&lt;/li&gt;
&lt;li&gt;要么处理器添加了额外状态（CSR），要么导致现有 CSR 的访问复杂化&lt;/li&gt;
&lt;li&gt;基于 for 循环的 packd-SIMD 程序可能要根据数据对齐模式修改多个版本的代码，使得代码生成复杂化，产生额外开销&lt;/li&gt;
&lt;li&gt;新的硬件寻址模式必然要消耗大量的指令编码空间，而且也要消耗一些硬件资源来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;即使实现了非对齐访问，在某些实现中可能性能很差；而且硬件处理非对齐访问时可能会将其拆分成多个子指令来处理，此时需要额外的同步机制来保证访问的原子性。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;标准中非对齐访问的原子性不是必须的，这样 EEI 就可以自由选择是用不可见的 machine trap 还是软件 handler 来处理非对齐访问。如果硬件支持非对齐访问，那么软件只需要直接用简单的 load/store 即可，发生非对齐访问时，硬件会自动优化。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="memory-ordering-instructions"&gt;Memory Ordering Instructions&lt;/h3&gt;
&lt;p&gt;RISC-V 支持在一个单一的用户地址空间内运行多个 hart，每个 hart 都有自己的 pc 和 register，执行自己的指令流。而由 EEI 来完成 hart 的创建和管理。不同 hart 之间可以通过共享存储器来实现通信和同步，又因为 RISC-V 使用存储器松散一致性模型 &lt;code&gt;RVWMO&lt;/code&gt;，所以需要 FENCE 指令来定义不同 hart 之间的指令执行顺序。从原则上讲，FENCE 之后的指令观测不到 FENCE 之前的指令行为，即 FENCE 像一道屏障一样，隔断了前后的指令流。&lt;/p&gt;
&lt;p&gt;RISC-V 把数据存储器访问分为了 4 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I：设备读 device-input&lt;/li&gt;
&lt;li&gt;O：设备写 device-output&lt;/li&gt;
&lt;li&gt;R：存储器读 device-read&lt;/li&gt;
&lt;li&gt;W：存储器写 device-write&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配合前后的概念，所以可以实现很多种组合，达到非常精细的控制。FENCE 中没有定义的字段是为了以后更细精度的扩展而设置的保留位。为了保持前向兼容，硬件应该忽略这些 bit 位，同时软件应该将这些 bit 位设置为全 0。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;我们选择松散一致性模型的目的是让一个简单的微架构能获得高性能的同时也方便未来进行扩展。将 I/O 和 memory 操作分离开来的好处是可以避免不必要的串行化。一个简单的微架构可以忽略 FENCE 中的前序和后序字段，保守地把所有的 FENCE 指令都当成最严格的 FENCE 指令来执行即可。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="environment-call-and-breakpoints"&gt;Environment Call and Breakpoints&lt;/h3&gt;
&lt;p&gt;系统指令一般是在特权模式使用，全部是 I 类型的指令。大概可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动 read-modify-write CSR 的指令&lt;/li&gt;
&lt;li&gt;其他特权指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里只描述非特权指令，只有两条且都向 EEI 会出发一条精确的服务请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ECALL&lt;/code&gt; 用来向 EEI 发送服务请求，请求的参数则一般放在寄存器文件中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EBREAK&lt;/code&gt; 用来把控制权转移给 debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;系统指令经过精心设计，可以在简单实现中用软件 trap 实现，而一些高端实现可能直接用硬件实现该指令。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="hint-instructions"&gt;HINT Instructions&lt;/h3&gt;
&lt;p&gt;HINT 指令一般用来给微架构传达性能提示。RV32I 给 HINT 预留了大量的编码空间，且全部用 rd = x0 的计算指令来表示。所以 HINT 和 NOP 类似，只会导致 pc 向前移动以及改变性能计数器，除此之外不会改变硬件架构中任何可见的状态。实现中直接把 HINT 忽略也是符合标准的。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;HINT 设计成这样的目的是方便硬件实现。简单实现中既可以把 HINT 当成一条恰好并不会产生任何影响的指令来走完所有 pipeline stage，也可以直接把它丢弃。&lt;/p&gt;
&lt;p&gt;虽然 HINT 编码空间很大，而且划分了 standard 空间和 custom 空间，但是目前还没有定义好 standard HINT。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="zifencei"&gt;Zifencei&lt;/h2&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;先讨论一个问题：假设一个指令流，前面的有条指令向 memory 某个地址 store 了一个新值，后面需要从该地址取指，那么后面的指令一定可以读取到前面的新值吗？&lt;/p&gt;
&lt;p&gt;答案是：不一定。因为 pipeline 是有深度的，假设前面的这两条指令是背靠背的，那么前序指令结果还没写入的时候后续指令已经完成了取指、译码，开始执行了，所以后续取指的是旧值。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，引入了 FENCE.I 指令，用来约束 store 和取值之间的顺序关系。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这个子集只包含一条指令 &lt;code&gt;FENCE.I&lt;/code&gt;，它可以实现对同一个 hart 的 instruction memory 的写指令和取指之间的显式的同步控制，目前这是唯一一个可以保证 hart 内部 store 和 fetch 之间可见性的标准机制。&lt;/p&gt;
&lt;p&gt;这条指令用来同步一个 hart 的 data 和 instruction 之间的关系，如果没有这条指令，RISC-V 就无法保证后续的取值操作能观测到前序的 store 结果。因为 FENCE.I 只用来处理单个 hart 内部的关系，所以如果有多个 hart，为了保证某个 hart 的 store 结果可以被其他 hart 观测到，应该在 FENCE.I 之前先调用一条 FENCE 指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step1：本 hart 完成 store 指令&lt;/li&gt;
&lt;li&gt;step2：本 hart 执行 fence 指令&lt;/li&gt;
&lt;li&gt;step3：本 hart 请求所有 hart 执行 fence.i 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;为了支持各种不同的实现，FENCE.I 指令做过精心的设计。简单实现可以直接 flush 流水线，清空 I-cache 即可。复杂一些的实现可能会有更高级的操作。&lt;/p&gt;
&lt;p&gt;FENCI.I 之前是 I 子集的一部分，但是因为下面两个原因，从 I 子集中挪了出来，不再是必须实现的指令了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在某些系统中，实现 FENCE.I 的代价很大。比如有些设计中 I-cache 和 D-cache 都是 incoherent 形式，一旦遇到 FENCE.I 指令，就必须清空两个 cache。如果在共享 cache / memory 之前有多级独立的 I/D cache，这个问题会更加严重&lt;/li&gt;
&lt;li&gt;在类 Unix 系统中，这条指令并没有强大到足以在 user level 使用。因为 FENCE.I 只能处理 hart 内部的同步，但是 OS 可能会在遇到 FENCE.I 时重新调度 user hart，所以现在 Linux ABI 都是要求产生一个系统调用来保证取指的 coherent&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="rv32e"&gt;RV32E&lt;/h2&gt;
&lt;p&gt;RV32E 是专门为嵌入式 Emmbedded 设计的 ISA，目前还是 draft 1.9 状态，它和 RV32I 的唯一区别就是把 register 的数量减少到了 16 个。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;实际上一开始是拒绝专门设计一个新的子 ISA 的，但是后来考虑到 32bit MCU 的需求，最终定义了这个子集，将来可能还会有 RV64E。&lt;/p&gt;
&lt;p&gt;我们发现在 RV32I 的小核中，高 16 个 register 大概占了除 memory 之外总面积的四分之一，所以去掉这 16 个 register 可以节省大约 25% 的面积和功耗。&lt;/p&gt;
&lt;p&gt;这个改变也对软件的调用惯例和 ABI 提出了要求。&lt;/p&gt;
&lt;p&gt;RV32E 可以和任何标准 extension 组合使用。曾经考虑过和 RV32E 配合时，定义一个新版的只有 16-entry 的 FP register file，但是最终放弃了，改用 &lt;code&gt;zfinx&lt;/code&gt; 扩展 ，它直接使用 integer register file，所以省去了很多指令。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RV32E 的 ISA 和 RV32I 完全一样，但是因为 register 只有 16 个，所有指令中 index 的字段可以释放出几 bit，未来的标准指令扩展都不会用到这些字段，所以可以给自定义扩展指令来使用。&lt;/p&gt;
&lt;h2 id="rv64i"&gt;RV64I&lt;/h2&gt;
&lt;p&gt;RV64I 是 RV32I 的扩展。和 RV32I 的区别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XLEN&lt;/code&gt; 变成了 64，即 register 的位宽是 64bit。&lt;/li&gt;
&lt;li&gt;RV64I 的大部分指令的操作数位宽都是 XLEN bit，但是也有一些附加的指令来操作 32bit 的数，这些指令都在 opcode 后面加了 &lt;code&gt;W&lt;/code&gt; 后缀来区分（W = word）。这些 &lt;code&gt;*W&lt;/code&gt; 指令会忽略掉高 32bit 数据，产生的结果也只保留 32bit 结果，然后把它符号位扩展到 64bit 后保存在 register 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="rv128i"&gt;RV128I&lt;/h2&gt;
&lt;p&gt;目前还是 draft 1.7 状态，定义这个子 ISA 的目的就是为了支持更大的地址空间。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;目前暂时还不是很清楚我们什么时候需要比 64bit 更大的地址空间，世界上 Top500 的超级计算机拥有超过 1PB 的 DRAM，这需要超过 50bit 的地址线。一些仓储级的计算机已经包含了更大的 DRAM，而且固态硬盘和 interconnect 技术的发展可以能会产生更大地址空间的需求。万亿级别的系统研究需要 100PB 的空间，大概占用 57 根地址线。根据历史增长速度看，大概在 2030 年前就有可能超过 64bit 的范围。&lt;/p&gt;
&lt;p&gt;历史证明，无论何时只要出现地址不够用的情况，architect 设计者们就会重复以前的争论，使用各种技术来扩充寻址范围，但是最终，128bit 的寻址方案将作为最简单、最佳解决方案而被采用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RV128I 在 RV64I 的基础上定义，就如同 RV64I 在 RV32I 上定义一样，保留了 &lt;code&gt;*W&lt;/code&gt; 指令不变，只不过新增了如何在 128bit 寄存器中操作 64bit 的指令，用 &lt;code&gt;*D&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;h2 id="zicsr"&gt;Zicsr&lt;/h2&gt;
&lt;p&gt;RISC-V 专门定义了一组 (control and status register, CSR) 寄存器来记录配置和运行状态，这些寄存器是内部寄存器，使用专有的 12bit 地址编码空间。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;CSR 主要是在 Priviledge 架构中使用，但是 Unpriviledge 架构中也会用到一些，比如计数器和计时器，浮点状态等。&lt;/p&gt;
&lt;p&gt;因为计数器和计时器等不再是 base ISA 中的必须强制性实现的了，所以访问这些 CSR 的指令就独立出来自成一章。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;只要程序中有指令会修改或者是行为受 CSR 影响，那么就会发生隐式或是显式的 CSR 访问。比如说，在某些修改或受 CSR 影响的指令执行完之后，后续修改 CSR 或受 CSR 影响的指令执行之前，会产生 CSR 访问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一条带有 CSR 读的指令，在指令执行之前会先读回 CSR 的状态&lt;/li&gt;
&lt;li&gt;对于一条带有 CSR 写的指令，在指令执行之后会更新 CSR 的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSR 的访问是 weakly ordered，所以其他 hart 观测 CSR 的顺序可能和程序中的顺序不一样，特别是，CSR 和 memory 的访问没有顺序关系，除非 CSR 会修改访问 memory 指令的执行，或者是使用特权指令集中定义的 Memory-Ordering PMAs 做了明确的顺序要求。对于 FENCE 指令来说，CSR 读被当作设备输入 (I)，CSR 写被当作设备输出 (O)。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;CSR 按照第二卷中 Memory-Ordering PMAs 章节定义的 weakly ordered memory-mapped I/O region 模型操作，所以 CSR 的访问顺序和 memory-mapped I/O 访问的约束一致。&lt;/p&gt;
&lt;p&gt;对 CSR 的顺序设置约束的原因是为了支持对主存及 memory-mapped I/O 访问和 time CSR 的排序。除了 &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;cycle&lt;/code&gt;, &lt;code&gt;mycle&lt;/code&gt; 这三类 CSR，两卷标准中定义的其他 CSR 都对其他 hart 不可见，所以这些 CSR 的访问顺序和 FENCE 的顺序可以是任意顺序，都是符合标准的。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="counter"&gt;Counter&lt;/h2&gt;
&lt;p&gt;RISC-V 定义了 32 个 64bit 的 Unpriviledge 只读性能计数器和计时器，其中前 3 个有特定的含义：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;CSR 名字&lt;/th&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CYCLE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;保存了 hart 执行到当前的周期数，使用 RDCYCLE[H] 来读取低 / 高 32bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;TIME&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;保存了 hart 的 wall-clock 周期数，使用 RDTIME[H] 来读取低 / 高 32bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;INSTRET&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;保存了 hart 退休的总指令数量，使用 RDINSTRET[H] 来读取低 / 高 32bit&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以通过一组非特权指令通过 0xC00-0xC1F 地址访问（高 32bit 可以用 0xC80-0xC9F 访问）这些计数器 / 计时器。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;这个子集之前是在 RV32I 中，后来分离出来单独作为一个子集，目前是 draft 2.0 版本，目测以后也不会大改。&lt;/p&gt;
&lt;p&gt;在 V2.2 版本中这 3 个 CSR 指令作为 RV32I 的一部分是强制实现的，但是现在独立后就不是强制性的了，但是还是推荐实现这 3 个 CSR，因为它们对于基本的性能分析、自适应、动态优化来说是必不可少的。而且也应该以较小的代价实现其他计数器，来辅助诊断性能问题。&lt;/p&gt;
&lt;p&gt;这些计数器必须是 64bit，即使是 RV32I 也是如此，否则位宽太少软件很难判断是否发生了 overflow。（简单算一下就知道 64bit 的表示范围非常大，可以覆盖任何性能计数的需求）&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;剩余的 29 个 CSR 名称为 &lt;code&gt;hpmcounter3&lt;/code&gt;-&lt;code&gt;hpmcounter31&lt;/code&gt;（hardware performance counter），它们作为可编程的计数器能针对某些事件进行计数，这些计数器可以通过特权指令来配置。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;特权架构中定义了访问和配置这些 hpm 的 privileged CSR，这些 hpm 可以用来对一些硬件指标做统计，比如执行的 F 指令条数，L1 I$ 的 miss 次数等等。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="m-extension"&gt;M Extension&lt;/h2&gt;
&lt;p&gt;把乘除法指令从 I 子集中分离出来，可以简化低端 core 的实现，或者对于那些乘除法不常出现的应用，用另外一个加速器来实现。&lt;/p&gt;
&lt;p&gt;如果同时需要乘法结果的高低两部分，推荐使用下面的顺序，同时保证 rs1 和 rs2 的值和顺序不变，且 rdh != rs1 or rs2：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;MULH&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="no"&gt;S&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="no"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rdh&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;span class="nf"&gt;MUL&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="no"&gt;rdl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样硬件实现时会把它们融合成一条指令来执行，只进行一次乘法。&lt;/p&gt;
&lt;p&gt;同理，除法也可以按照类似的方法实现，硬件实现时只会进行一次除法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;DIV&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rdq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;span class="nf"&gt;REM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rdr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MUL 不需要（没必要）区分 signed/unsigned，MULH 则需要区分 singed/unsigned&lt;/li&gt;
&lt;li&gt;大多数 ISA 中除以 0 都会触发异常，跳转到 trap，但是 RISC-V 做了简化，不会产生异常，可以简化硬件实现&lt;/li&gt;
&lt;li&gt;RISC-V 的所有的计算指令都不会产生 exception&lt;/li&gt;
&lt;li&gt;RISC-V 虽然不会产生 exception，但是对除 0 的结果做了特殊规定：商的所有 bit 设置为全 1&lt;/li&gt;
&lt;li&gt;设置为全 1 是精心设计过的：对于无符号除法来说，全 1 就是最大值，而且也天然符合硬件除法器的输出，无需任何修改；对于有符号除法来说，一般都是先转成无符号来算，所以也没有问题。这样设计可以最大程度地简化硬件设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="a-extension"&gt;A Extension&lt;/h2&gt;
&lt;p&gt;A 子集包含了对 memory 进行原子性的 read-modify-write 操作的指令，目的是同步多个共享同一个 memory 空间的不同 hart。
A 指令支持 unordered, acquire, release, sequentially 等各种内存一致性模型，这些指令可以让 RISC-V 支持 RCsc 存储器一致性模型。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;经过大量辩论后，编程语言社区和体系结构社区最后达成一致：用 release consistency 作为存储器一致性模型，所以围绕着这个模型建立了 A 子集。&lt;/p&gt;
&lt;p&gt;背景知识：3 种最有代表性的内存一致性模型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;访问 memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;按序一致性模型 Sequential Consistency Model&lt;/td&gt;
&lt;td&gt;每个 hart 看到的都是 program-order&lt;/td&gt;
&lt;td&gt;原子性、串行化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;松散一致性模型 Relaxed Consistency Model&lt;/td&gt;
&lt;td&gt;每个 hart 可以改变自己的存储器访问顺序&lt;/td&gt;
&lt;td&gt;性能、功能 balance&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;释放一致性模型 Release Consistency Model&lt;/td&gt;
&lt;td&gt;支持 acquire-release 机制&lt;/td&gt;
&lt;td&gt;更加松散&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;已知 base 子集使用的是 relaxed 模型，配合 FENCE 指令可以实现额外的顺序控制。但是为了更加高效地支持 release 模型，每个 A 指令都新增了两 bit：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ac&lt;/code&gt; 字段：表明本指令是 acquire 访问（上锁），屏障了它之后的 memory 操作，即在它之后的 memory 访问必须要等到这条 A 指令结束后才能开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rl&lt;/code&gt; 字段：表明本指令是 release 访问（释放锁），屏蔽了它之前的 memory 操作，即它必须等前面的 memory 访问都结束了才能开始&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果两个字段都是 0, 则这条 A 指令没有任何附加的约束；如果两个字段都是 1，则这条 A 指令是 sequential 模型，只能在前序指令结束、后序指令开始前执行。&lt;/p&gt;
&lt;p&gt;A 子集主要包含两大类指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Atomic Memory Operations, &lt;code&gt;AMO&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这些指令都是原子性的，也就是说读回数据和写回结果这段时间内这个地址不允许其他任何指令访问，也就是对这个地址 “ 上锁 ”。AMO 指令要求必须是对齐访问（32-bit 数据按照 4-byte 对齐；64-bit 数据要求按照 8-byte 对齐），否则会产生异常。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;设计 AMO 指令的原因是在高度并行系统中它比 LR/SC 指令的伸缩性更好。对于简单实现，可以直接用 LR/SC 来等价实现 AMO；而对于一个复杂实现，可以在 memory 控制器中实现 AMO 指令，而且如果 rd = x0 时可以优化掉读 memory 的操作。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;AMO 可以用来实现 memory 中的 parallel reductions，还可以用来更新 I/O 设备映射出的寄存器（比如 setting, clearing, toggle 比他位）。&lt;/p&gt;
&lt;p&gt;通过设置 ac/rl 字段，AMO 可以用来高效地实现 C11/C++ 11 中的 atmic memory operations。虽然 &lt;code&gt;FENCE R, RW&lt;/code&gt; 可以实现 acquire 效果，&lt;code&gt;FENCE RW, W&lt;/code&gt; 可以实现 release 效果，但是和 AMO 比起来引入了不必要的额外约束，所以 AMO 实现更加高效。&lt;/p&gt;
&lt;p&gt;下面是一个自旋锁的例子，整个流程就是 test-and-test-and-set，先测试锁是否可获取，如果可以就尝试获取，尝试完了测试是否获取成功，获取成功了就开始执行核心代码，核心代码执行完后再释放锁。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    li          t0, 1   # initialize swap value
again:
    lw            t1, (a0)      # load lock, lock is stored in a0 address
    bnez          t1, again     # check if lock is held
    amoswap.w.aq  t1, t0, (a0)  # attempt to acquire lock
    bnez          t1, again     # check agian
    # ...
    # critical section.
    # ...
    amoswap.w.r1  x0, x0, (a0)  # release lock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Load-Reserved/Store-Conditional, &lt;code&gt;LR&lt;/code&gt;/&lt;code&gt;SC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;和 ARM 中的 Load-Exclusive/Store-Exclusive 类似。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="rvwmo-model"&gt;RVWMO Model&lt;/h2&gt;
&lt;h2 id="f-extension"&gt;F Extension&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id="d-extension"&gt;D Extension&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id="extending-risc-v"&gt;Extending RISC-V&lt;/h2&gt;
&lt;h2 id="isa-extension-naming-conventions"&gt;ISA Extension Naming Conventions&lt;/h2&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="RISC-V"></category><category term="RISC-V"></category><category term="Spec"></category></entry></feed>